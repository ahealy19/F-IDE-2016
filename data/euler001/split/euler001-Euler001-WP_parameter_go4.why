theory Task
(* use why3.BuiltIn.BuiltIn *)

type bool =
  | True
  | False

(* use why3.Bool.Bool *)

type tuple0 =
  | Tuple0

(* use why3.Tuple0.Tuple01 *)

type unit = tuple0

(* use why3.Unit.Unit *)

(* use why3.Prelude.Prelude *)

function zero : int = 0

function one : int = 1

predicate infix_ls int int

predicate infix_gt (x:int) (y:int) = infix_ls y x

predicate infix_lseq (x:int) (y:int) = infix_ls x y \/ (x = y)

function infix_pl int int : int

function prefix_mn int : int

function infix_as int int : int

axiom Assoc : forall x:int, y:int, z:int. (infix_pl (infix_pl x y)
  z = infix_pl x (infix_pl y z))

(* clone algebra.Assoc with type t = int, function op = infix_pl,
  prop Assoc1 = Assoc *)

axiom Unit_def_l : forall x:int. (infix_pl zero x = x)

axiom Unit_def_r : forall x:int. (infix_pl x zero = x)

(* clone algebra.Monoid with type t1 = int, function unit = zero,
  function op1 = infix_pl, prop Unit_def_r1 = Unit_def_r,
  prop Unit_def_l1 = Unit_def_l, prop Assoc2 = Assoc *)

axiom Inv_def_l : forall x:int. (infix_pl (prefix_mn x) x = zero)

axiom Inv_def_r : forall x:int. (infix_pl x (prefix_mn x) = zero)

(* clone algebra.Group with type t2 = int, function inv = prefix_mn,
  function unit1 = zero, function op2 = infix_pl,
  prop Inv_def_r1 = Inv_def_r, prop Inv_def_l1 = Inv_def_l,
  prop Unit_def_r2 = Unit_def_r, prop Unit_def_l2 = Unit_def_l,
  prop Assoc3 = Assoc *)

axiom Comm : forall x:int, y:int. (infix_pl x y = infix_pl y x)

(* clone algebra.Comm with type t3 = int, function op3 = infix_pl,
  prop Comm1 = Comm *)

(* meta AC function infix_pl *)

(* clone algebra.CommutativeGroup with type t4 = int,
  function inv1 = prefix_mn, function unit2 = zero, function op4 = infix_pl,
  prop Comm2 = Comm, prop Inv_def_r2 = Inv_def_r,
  prop Inv_def_l2 = Inv_def_l, prop Unit_def_r3 = Unit_def_r,
  prop Unit_def_l3 = Unit_def_l, prop Assoc4 = Assoc *)

axiom Assoc5 : forall x:int, y:int, z:int. (infix_as (infix_as x y)
  z = infix_as x (infix_as y z))

(* clone algebra.Assoc with type t = int, function op = infix_as,
  prop Assoc1 = Assoc5 *)

axiom Mul_distr_l : forall x:int, y:int, z:int. (infix_as x (infix_pl y
  z) = infix_pl (infix_as x y) (infix_as x z))

axiom Mul_distr_r : forall x:int, y:int, z:int. (infix_as (infix_pl y z)
  x = infix_pl (infix_as y x) (infix_as z x))

function infix_mn (x:int) (y:int) : int = infix_pl x (prefix_mn y)

(* clone algebra.Ring with type t5 = int, function infix_mn1 = infix_mn,
  function infix_as1 = infix_as, function prefix_mn1 = prefix_mn,
  function infix_pl1 = infix_pl, function zero1 = zero,
  prop Mul_distr_r1 = Mul_distr_r, prop Mul_distr_l1 = Mul_distr_l,
  prop Assoc6 = Assoc5, prop Comm3 = Comm, prop Inv_def_r3 = Inv_def_r,
  prop Inv_def_l3 = Inv_def_l, prop Unit_def_r4 = Unit_def_r,
  prop Unit_def_l4 = Unit_def_l, prop Assoc7 = Assoc *)

axiom Comm4 : forall x:int, y:int. (infix_as x y = infix_as y x)

(* clone algebra.Comm with type t3 = int, function op3 = infix_as,
  prop Comm1 = Comm4 *)

(* meta AC function infix_as *)

(* clone algebra.CommutativeRing with type t6 = int,
  function infix_mn2 = infix_mn, function infix_as2 = infix_as,
  function prefix_mn2 = prefix_mn, function infix_pl2 = infix_pl,
  function zero2 = zero, prop Comm5 = Comm4, prop Mul_distr_r2 = Mul_distr_r,
  prop Mul_distr_l2 = Mul_distr_l, prop Assoc8 = Assoc5, prop Comm6 = Comm,
  prop Inv_def_r4 = Inv_def_r, prop Inv_def_l4 = Inv_def_l,
  prop Unit_def_r5 = Unit_def_r, prop Unit_def_l5 = Unit_def_l,
  prop Assoc9 = Assoc *)

axiom Unitary : forall x:int. (infix_as one x = x)

axiom NonTrivialRing : not (zero = one)

(* clone algebra.UnitaryCommutativeRing with type t7 = int,
  function one1 = one, function infix_mn3 = infix_mn,
  function infix_as3 = infix_as, function prefix_mn3 = prefix_mn,
  function infix_pl3 = infix_pl, function zero3 = zero,
  prop NonTrivialRing1 = NonTrivialRing, prop Unitary1 = Unitary,
  prop Comm7 = Comm4, prop Mul_distr_r3 = Mul_distr_r,
  prop Mul_distr_l3 = Mul_distr_l, prop Assoc10 = Assoc5, prop Comm8 = Comm,
  prop Inv_def_r5 = Inv_def_r, prop Inv_def_l5 = Inv_def_l,
  prop Unit_def_r6 = Unit_def_r, prop Unit_def_l6 = Unit_def_l,
  prop Assoc11 = Assoc *)

predicate infix_gteq (x:int) (y:int) = infix_lseq y x

(* clone relations.EndoRelation with type t8 = int,
  predicate rel = infix_lseq,  *)

axiom Refl : forall x:int. infix_lseq x x

(* clone relations.Reflexive with type t9 = int, predicate rel1 = infix_lseq,
  prop Refl1 = Refl *)

(* clone relations.EndoRelation with type t8 = int,
  predicate rel = infix_lseq,  *)

axiom Trans : forall x:int, y:int, z:int. infix_lseq x y -> infix_lseq y z ->
  infix_lseq x z

(* clone relations.Transitive with type t10 = int,
  predicate rel2 = infix_lseq, prop Trans1 = Trans *)

(* clone relations.PreOrder with type t11 = int, predicate rel3 = infix_lseq,
  prop Trans2 = Trans, prop Refl2 = Refl *)

(* clone relations.EndoRelation with type t8 = int,
  predicate rel = infix_lseq,  *)

axiom Antisymm : forall x:int, y:int. infix_lseq x y -> infix_lseq y x ->
  (x = y)

(* clone relations.Antisymmetric with type t12 = int,
  predicate rel4 = infix_lseq, prop Antisymm1 = Antisymm *)

(* clone relations.PartialOrder with type t13 = int,
  predicate rel5 = infix_lseq, prop Antisymm2 = Antisymm,
  prop Trans3 = Trans, prop Refl3 = Refl *)

(* clone relations.EndoRelation with type t8 = int,
  predicate rel = infix_lseq,  *)

axiom Total : forall x:int, y:int. infix_lseq x y \/ infix_lseq y x

(* clone relations.Total with type t14 = int, predicate rel6 = infix_lseq,
  prop Total1 = Total *)

(* clone relations.TotalOrder with type t15 = int,
  predicate rel7 = infix_lseq, prop Total2 = Total,
  prop Antisymm3 = Antisymm, prop Trans4 = Trans, prop Refl4 = Refl *)

axiom ZeroLessOne : infix_lseq zero one

axiom CompatOrderAdd : forall x:int, y:int, z:int. infix_lseq x y ->
  infix_lseq (infix_pl x z) (infix_pl y z)

axiom CompatOrderMult : forall x:int, y:int, z:int. infix_lseq x y ->
  infix_lseq zero z -> infix_lseq (infix_as x z) (infix_as y z)

(* clone algebra.OrderedUnitaryCommutativeRing with type t16 = int,
  predicate infix_gteq1 = infix_gteq, predicate infix_lseq1 = infix_lseq,
  function one2 = one, function infix_mn4 = infix_mn,
  function infix_as4 = infix_as, function prefix_mn4 = prefix_mn,
  function infix_pl4 = infix_pl, function zero4 = zero,
  prop CompatOrderMult1 = CompatOrderMult,
  prop CompatOrderAdd1 = CompatOrderAdd, prop ZeroLessOne1 = ZeroLessOne,
  prop Total3 = Total, prop Antisymm4 = Antisymm, prop Trans5 = Trans,
  prop Refl5 = Refl, prop NonTrivialRing2 = NonTrivialRing,
  prop Unitary2 = Unitary, prop Comm9 = Comm4,
  prop Mul_distr_r4 = Mul_distr_r, prop Mul_distr_l4 = Mul_distr_l,
  prop Assoc12 = Assoc5, prop Comm10 = Comm, prop Inv_def_r6 = Inv_def_r,
  prop Inv_def_l6 = Inv_def_l, prop Unit_def_r7 = Unit_def_r,
  prop Unit_def_l7 = Unit_def_l, prop Assoc13 = Assoc *)

(* use int.Int *)

function abs (x:int) : int = if infix_gteq x 0 then x else prefix_mn x

axiom Abs_le : forall x:int, y:int. infix_lseq (abs x) y <-> infix_lseq
  (prefix_mn y) x /\ infix_lseq x y

axiom Abs_pos : forall x:int. infix_gteq (abs x) 0

(* use int.Abs *)

function div int int : int

function mod int int : int

axiom Div_mod : forall x:int, y:int. not (y = 0) -> (x = infix_pl (infix_as y
  (div x y)) (mod x y))

axiom Div_bound : forall x:int, y:int. infix_gteq x 0 /\ infix_gt y 0 ->
  infix_lseq 0 (div x y) /\ infix_lseq (div x y) x

axiom Mod_bound : forall x:int, y:int. not (y = 0) -> infix_ls (prefix_mn
  (abs y)) (mod x y) /\ infix_ls (mod x y) (abs y)

axiom Div_sign_pos : forall x:int, y:int. infix_gteq x 0 /\ infix_gt y 0 ->
  infix_gteq (div x y) 0

axiom Div_sign_neg : forall x:int, y:int. infix_lseq x 0 /\ infix_gt y 0 ->
  infix_lseq (div x y) 0

axiom Mod_sign_pos : forall x:int, y:int. infix_gteq x 0 /\ not (y = 0) ->
  infix_gteq (mod x y) 0

axiom Mod_sign_neg : forall x:int, y:int. infix_lseq x 0 /\ not (y = 0) ->
  infix_lseq (mod x y) 0

axiom Rounds_toward_zero : forall x:int, y:int. not (y = 0) -> infix_lseq
  (abs (infix_as (div x y) y)) (abs x)

axiom Div_1 : forall x:int. (div x 1 = x)

axiom Mod_1 : forall x:int. (mod x 1 = 0)

axiom Div_inf : forall x:int, y:int. infix_lseq 0 x /\ infix_ls x y -> (div x
  y = 0)

axiom Mod_inf : forall x:int, y:int. infix_lseq 0 x /\ infix_ls x y -> (mod x
  y = x)

axiom Div_mult : forall x:int, y:int, z:int [div (infix_pl (infix_as x y) z)
  x]. infix_gt x 0 /\ infix_gteq y 0 /\ infix_gteq z 0 -> (div (infix_pl
  (infix_as x y) z) x = infix_pl y (div z x))

axiom Mod_mult : forall x:int, y:int, z:int [mod (infix_pl (infix_as x y) z)
  x]. infix_gt x 0 /\ infix_gteq y 0 /\ infix_gteq z 0 -> (mod (infix_pl
  (infix_as x y) z) x = mod z x)

(* use int.ComputerDivision *)

function sum_multiple_3_5_lt int : int

axiom SumEmpty : (sum_multiple_3_5_lt 0 = 0)

axiom SumNo : forall n:int. infix_gteq n 0 -> not (mod n 3 = 0) /\ not (mod n
  5 = 0) -> (sum_multiple_3_5_lt (infix_pl n 1) = sum_multiple_3_5_lt n)

axiom SumYes : forall n:int. infix_gteq n 0 -> (mod n 3 = 0) \/ (mod n
  5 = 0) -> (sum_multiple_3_5_lt (infix_pl n 1) = infix_pl
  (sum_multiple_3_5_lt n) n)

axiom div2 : forall x:int. exists y:int. (x = infix_as 2 y) \/ (x = infix_pl
  (infix_as 2 y) 1)

(* use int.Div2 *)

axiom mod_div_unique : forall x:int, y:int, q:int, r:int. infix_gteq x 0 /\
  infix_gt y 0 /\ (x = infix_pl (infix_as q y) r) /\ infix_lseq 0 r /\
  infix_ls r y -> (q = div x y) /\ (r = mod x y)

axiom mod_succ_1 : forall x:int, y:int. infix_gteq x 0 /\ infix_gt y 0 ->
  not (mod (infix_pl x 1) y = 0) -> (mod (infix_pl x 1) y = infix_pl (mod x
  y) 1)

axiom mod_succ_2 : forall x:int, y:int. infix_gteq x 0 /\ infix_gt y 0 ->
  (mod (infix_pl x 1) y = 0) -> (mod x y = infix_mn y 1)

axiom div_succ_1 : forall x:int, y:int. infix_gteq x 0 /\ infix_gt y 0 ->
  (mod (infix_pl x 1) y = 0) -> (div (infix_pl x 1) y = infix_pl (div x y) 1)

axiom div_succ_2 : forall x:int, y:int. infix_gteq x 0 /\ infix_gt y 0 ->
  not (mod (infix_pl x 1) y = 0) -> (div (infix_pl x 1) y = div x y)

axiom mod2_mul2 : forall x:int. (mod (infix_as 2 x) 2 = 0)

axiom mod2_mul2_aux : forall x:int, y:int. (mod (infix_as y (infix_as 2 x))
  2 = 0)

axiom mod2_mul2_aux2 : forall x:int, y:int, z:int, t:int. (mod (infix_pl
  (infix_as y (infix_as 2 x)) (infix_as z (infix_as 2 t))) 2 = 0)

axiom div2_mul2 : forall x:int. (div (infix_as 2 x) 2 = x)

axiom div2_mul2_aux : forall x:int, y:int. (div (infix_as y (infix_as 2 x))
  2 = infix_as y x)

axiom div2_add : forall x:int, y:int. (mod x 2 = 0) /\ (mod y 2 = 0) -> (div
  (infix_pl x y) 2 = infix_pl (div x 2) (div y 2))

axiom div2_sub : forall x:int, y:int. (mod x 2 = 0) /\ (mod y 2 = 0) -> (div
  (infix_mn x y) 2 = infix_mn (div x 2) (div y 2))

(* use DivModHints *)

axiom tr_mod_2 : forall n:int. infix_gteq n 0 -> (mod (infix_as n (infix_pl n
  1)) 2 = 0)

function tr (n:int) : int = div (infix_as n (infix_pl n 1)) 2

axiom tr_repr : forall n:int. infix_gteq n 0 -> (infix_as n (infix_pl n
  1) = infix_as 2 (tr n))

axiom tr_succ : forall n:int. infix_gteq n 0 -> (tr (infix_pl n 1) = infix_pl
  (infix_pl (tr n) n) 1)

(* use TriangularNumbers *)

function closed_formula_aux (n:int) : int = let n3 = div n 3 in
  let n5 = div n 5 in let n15 = div n 15 in infix_mn (infix_pl (infix_as 3
  (tr n3)) (infix_as 5 (tr n5))) (infix_as 15 (tr n15))

predicate p (n:int) = (sum_multiple_3_5_lt (infix_pl n
  1) = closed_formula_aux n)

axiom mod_15 : forall n:int. (mod n 15 = 0) <-> (mod n 3 = 0) /\ (mod n
  5 = 0)

axiom Closed_formula_0 : p 0

axiom Closed_formula_n : forall n:int. infix_gt n 0 -> p (infix_mn n 1) ->
  not (mod n 3 = 0) /\ not (mod n 5 = 0) -> p n

axiom Closed_formula_n_3 : forall n:int. infix_gt n 0 -> p (infix_mn n 1) ->
  (mod n 3 = 0) /\ not (mod n 5 = 0) -> p n

axiom Closed_formula_n_5 : forall n:int. infix_gt n 0 -> p (infix_mn n 1) ->
  not (mod n 3 = 0) /\ (mod n 5 = 0) -> p n

axiom Closed_formula_n_15 : forall n:int. infix_gt n 0 -> p (infix_mn n 1) ->
  (mod n 3 = 0) /\ (mod n 5 = 0) -> p n

function b : int = 0

axiom Induction : (forall n:int. infix_lseq 0 n -> (forall k:int. infix_lseq
  0 k /\ infix_ls k n -> p k) -> p n) -> (forall n:int. infix_lseq 0 n -> p
  n)

axiom Induction_bound : (forall n:int. infix_lseq b n -> (forall k:int.
  infix_lseq b k /\ infix_ls k n -> p k) -> p n) -> (forall n:int. infix_lseq
  b n -> p n)

(* clone int.Induction with , function bound = b, predicate p1 = p,
  prop Induction_bound1 = Induction_bound, prop Induction1 = Induction *)

axiom Closed_formula_ind : forall n:int. infix_lseq 0 n -> p n

function closed_formula (n:int) : int = let n3 = div n 3 in
  let n5 = div n 5 in let n15 = div n 15 in div (infix_mn (infix_pl (infix_as
  3 (infix_as n3 (infix_pl n3 1))) (infix_as 5 (infix_as n5 (infix_pl n5
  1)))) (infix_as 15 (infix_as n15 (infix_pl n15 1)))) 2

axiom div_15 : forall n:int. infix_lseq 0 n -> infix_gteq (div n 15) 0

axiom div_5 : forall n:int. infix_lseq 0 n -> infix_gteq (div n 5) 0

axiom div_3 : forall n:int. infix_lseq 0 n -> infix_gteq (div n 3) 0

axiom Closed_Formula : forall n:int. infix_lseq 0 n -> (sum_multiple_3_5_lt
  (infix_pl n 1) = closed_formula n)

(* use SumMultiple *)

type char =
  | Mk_char (code:int)

function uppercase char : char

function lowercase char : char

axiom uppercase_alpha : forall c:int. infix_lseq 97 c /\ infix_lseq c 122 ->
  (uppercase (Mk_char c) = Mk_char (infix_mn c 32))

axiom uppercase_other : forall c:int. infix_lseq 0 c /\ infix_ls c 97 \/
  infix_ls 122 c /\ infix_lseq c 127 -> (uppercase (Mk_char c) = Mk_char c)

axiom lowercase_alpha : forall c:int. infix_lseq 65 c /\ infix_lseq c 90 ->
  (lowercase (Mk_char c) = Mk_char (infix_pl c 32))

axiom lowercase_other : forall c:int. infix_lseq 0 c /\ infix_ls c 65 \/
  infix_ls 90 c /\ infix_lseq c 127 -> (lowercase (Mk_char c) = Mk_char c)

(* use string.Char *)

type list 'a =
  | Nil
  | Cons 'a (list 'a)

(* use list.List *)

function infix_plpl (l1:list 'a) (l2:list 'a) : list 'a =
  match l1 with
  | Nil -> l2
  | Cons x1 r1 -> Cons x1 (infix_plpl r1 l2)
  end

axiom Append_assoc : forall l1:list 'a, l2:list 'a, l3:list 'a. (infix_plpl
  l1 (infix_plpl l2 l3) = infix_plpl (infix_plpl l1 l2) l3)

axiom Append_l_nil : forall l:list 'a. (infix_plpl l (Nil:list 'a) = l)

function length (l:list 'a) : int =
  match l with
  | Nil -> 0
  | Cons _ r -> infix_pl 1 (length r)
  end

axiom Length_nonnegative : forall l:list 'a. infix_gteq (length l) 0

axiom Length_nil : forall l:list 'a. (length l = 0) <-> (l = Nil:list 'a)

(* use list.Length *)

axiom Append_length : forall l1:list 'a, l2:list 'a. (length (infix_plpl l1
  l2) = infix_pl (length l1) (length l2))

predicate mem (x:'a) (l:list 'a) =
  match l with
  | Nil -> false
  | Cons y r -> (x = y) \/ mem x r
  end

(* use list.Mem *)

axiom mem_append : forall x:'a, l1:list 'a, l2:list 'a. mem x (infix_plpl l1
  l2) <-> mem x l1 \/ mem x l2

axiom mem_decomp : forall x:'a, l:list 'a. mem x l -> (exists l1:list 'a, l2:
  list 'a. (l = infix_plpl l1 (Cons x l2)))

(* use list.Append *)

function reverse (l:list 'a) : list 'a =
  match l with
  | Nil -> Nil:list 'a
  | Cons x r -> infix_plpl (reverse r) (Cons x (Nil:list 'a))
  end

axiom reverse_append : forall l1:list 'a, l2:list 'a, x:'a. (infix_plpl
  (reverse (Cons x l1)) l2 = infix_plpl (reverse l1) (Cons x l2))

axiom reverse_cons : forall l:list 'a, x:'a. (reverse (Cons x l) = infix_plpl
  (reverse l) (Cons x (Nil:list 'a)))

axiom cons_reverse : forall l:list 'a, x:'a. (Cons x (reverse l) = reverse
  (infix_plpl l (Cons x (Nil:list 'a))))

axiom reverse_reverse : forall l:list 'a. (reverse (reverse l) = l)

axiom reverse_mem : forall l:list 'a, x:'a. mem x l <-> mem x (reverse l)

axiom Reverse_length : forall l:list 'a. (length (reverse l) = length l)

(* use list.Reverse *)

type ref 'a =
  | Mk_ref (contents:'a)

function prefix_ex (x:ref 'a) : 'a = contents x

(* use ref.Ref *)

type prdata =
  | PrChar char
  | PrInt int

(* use io.StdIO *)

(* meta syntax_type type int, "int", 0 *)

(* meta syntax_type type real, "real", 0 *)

(* meta syntax_logic predicate infix_eq, "(%1 = %2)", 0 *)

goal WP_parameter_go "expl:VC for go" : forall cur_linenum:int, cur_pos:int,
  current_line:list prdata, flushed:list (list prdata). ("asym_split"
  "stop_split" "expl:precondition" infix_lseq 0 71 /\ infix_lseq 71 255) ->
  (forall cur_pos1:int, current_line1:list prdata.
  ("stop_split" (cur_pos1 = infix_pl cur_pos 1)) /\
  ("stop_split" (current_line1 = Cons (PrChar (Mk_char 71)) current_line)) ->
  ("asym_split" "stop_split" "expl:precondition" infix_lseq 0 79 /\
  infix_lseq 79 255) -> (forall cur_pos2:int, current_line2:list prdata.
  ("stop_split" (cur_pos2 = infix_pl cur_pos1 1)) /\
  ("stop_split" (current_line2 = Cons (PrChar (Mk_char 79))
  current_line1)) -> ("asym_split" "stop_split"
  "expl:precondition" infix_lseq 0 58 /\ infix_lseq 58 255) ->
  (forall cur_pos3:int, current_line3:list prdata.
  ("stop_split" (cur_pos3 = infix_pl cur_pos2 1)) /\
  ("stop_split" (current_line3 = Cons (PrChar (Mk_char 58))
  current_line2)) -> ("asym_split" "stop_split"
  "expl:precondition" infix_lseq 0 32 /\ infix_lseq 32 255) ->
  (forall cur_pos4:int, current_line4:list prdata.
  ("stop_split" (cur_pos4 = infix_pl cur_pos3 1)) /\
  ("stop_split" (current_line4 = Cons (PrChar (Mk_char 32))
  current_line3)) -> (forall cur_linenum1:int, cur_pos5:int, current_line5:
  list prdata, flushed1:list (list prdata). ("stop_split" (cur_pos5 = 0)) /\
  ("stop_split" (current_line5 = Nil:list prdata)) /\
  ("stop_split" (cur_linenum1 = infix_pl cur_linenum 1)) /\
  ("stop_split" (flushed1 = Cons (reverse current_line4) flushed)) ->
  ("expl:postcondition" (cur_linenum1 = infix_pl cur_linenum 1)))))))

end
